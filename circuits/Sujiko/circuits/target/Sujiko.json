{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":8057665436007338946,"abi":{"parameters":[{"name":"question","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"solution","type":{"kind":"array","length":9,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+2ayXLTQBCGR7a8SLYTZydVcGK5AbLlJb7lwL69g5LYVVwoiuIBfOICT8IFHpFMMS21O6MEx92xFKarUpY8ra/bo5nRRH976q+1z/98cwyfFZVvx+YzWs163jkjFI0x7Mlwx0MZ7kiIO46FuAOhfpgIcWdC3KkMN05kuP0oBeoJryfiTU14n7A95hiMrEgqR68EOVZKkGNVIMfb9gQUWvnFVtJTGa7UE9s9AQ233E/Airq5CR8QNveq6Kvir9y1EuRYL0GOjRLk2CxBjkEJcgxLkGOrBDm2BXJU+F8bWOD1uV7o9EKiJ2rTtOkbqTsKv3cBhn4IVdVFg+9+kBgVdC3jdrgXIC43/ygazGwPQcb84wAxBfgnwPdl+FHDcJ7NF/mKxK0SP3oN9nmOfJ4jH8x+gXxe5Pi8RD4vc3xeIZ9XOT6vkc/rHJ83yOdNjs9b5PM2x+cd8nmX4/Me+bzP8fmAfD4Qnw46BntmfGC8SMzX8/k0FB6PSYf0g0K/E2LXZGKfeCSeUotzQZH4oRKd+z2PxIN8aP/Ave6AzzzLh7b584u/A9pqqA3ur36W3Ed+trEFfk/Q8VNzDPdMcn2XGu/adiz541jaGnOVGvRHFX0H/Qr93MT+pC1Abf58MU5ozn0UB7Mgjxrxf2zON81nHV0D13ct8esk/kLelu9ovwQW/8Dir/ctj8xxy/zpMfQNrlEX5xnfq824Z1vT+PijU9u6xccf94Ffl+mfBPgNmf6ZAL8p0z/pHiqQ4Z8BP5TpnyPgt0T4/XR8tmX6ZwD8jkz/pPwNGX46fjZF+HEE/K5M/umebUuGPwb+tsz4Sf/H2pHJfwr8XRF+vw/7pj2VGd3T7qPv+fYvvem/7mkhfkhyldrT7pN8aP/gfatuO7Dk2rW00WfIgSXOgSWOjbXLyNpgZDUYWTuMrA4ji7Pv6wXNa5uR1WZk1RhZRR2rW4wszjHRKmhePiOry8gq6pjgnI8hI6uo62qVkbXJyIL/GW3vILQdm89oRYNcfUuuFUuu4G97N2jbR7WR7+cvHz99VcSoQOSRY2gPcxK4R66v5nApH5+HV7Tfs7D0gpkKYfPF+Mfm+2gFGx/9vTna4GVdTdnFMx+1Y//v5hz/PvhcpYpiNk56sziZJcPk7GxwmmwTvrYK6qff5rjkot6k5KKetIjCKurdYrFpsEaxaeiRePh+4Lb/TWw6RH62sQV+D9DxQ3MsLDZNnNiU+eeJTffNeZHFprvmGItNP+EaZd+QHpvzaCUbjYTFpiNZsSl7mSwjNo0nsmJTJmbJiE2ZmCUkNp3Iik3jSFZsysQgGbEpE1tlxKZMbBUSmwayYlMmZsmITZkYKiM2xQNZsSkTs2TEpkxslRGbRmkxw54Mf2oTrBj7p08FH4ihDWLfQd/z7b/iwb/uySF+SHKV2pPfIfnQ/sH7bt12aMm1a2mjz6hDS5xDSxwba5+RtcnIajKy9hhZG4wszr5vFDSvXUZWp6Aszt9YZ2Rx3sedgubVZmTVGFmca842I6vFyPIZWUVdC7cYWUWdQ5xjgnP9ChlZnHO7qGPV7QvXt0a7feFyrCoji3NMcK4TnHuToo6vrgCrTEUbtv/n2Yo2/JwEYnL9MkUbNi7NJbZwylCw8cucu4KN1fnnwum05AUbiSvYuNpuoGBjssaCjcQj8fD9wG2uYGPx94LfGgo2pq5gI/N3BRvXMVewcbm5go3LzRVsXG6uYOMKftkLNiauYOPS/F3BxrXNFWy4F/Puxbwr2FgfyxVsrC8vV7CxHMsVbCzHcgUb61u/XMHGciy3L1zfGu32hcuxXMHG7RhfrmDjoj9bwUaQk8CqBRtBThucu4KNRVu2YOMPiCH2mutwAAA=","debug_symbols":"7ZzbauMwGITfxde+8EiyDn2VZSk5tRhCEnJYWILffe2k3kDXG5gp9Oq/qxyNKjIjAt8kulbrzfLy/trt3van6uXHtdruV4tzt98No2vV3B6dDovdODqdF8dz9eJ9U1eb3Xr4q419Xb112031El1f/zO1JP8xFU3T/p3rm/5nXWF28eimxXP4wuJudvEy7TzgKzv3c4sHN+08BH3nw2B57Lbb7v31sxPXKuS5f/x0q6HQkrbhJeAljpd4XhJ4SctLIi9JvIR3v+Xdj7z7kXc/8u5H3v3Iux959yPvfuTdj7z7kXc/8e4n3v3Eu5949xPvfuLdT7z7iXc/8e4n3v3Mu5959zPvfubdz7z7mXc/8+5n3v3Mu5959wvvfuHdL7z7hXe/8O4X3v3Cu1949wvvfuHdHx4JGggaJ2i8oAmCphU0UdAkQZMFjZADCDmAkAMIOYCQAwg5gJADCDmAkAMIOYCQAyfkwAk5cEIOnJADJ+TACTlwQg6ckAMn5MDN5iC7/KHJEZ8lvuEl4CWOk/Q3fHStPP8meP4sBP4oBP4kBP4gBP4cBP4YBP4UBP4QBP4MGA8zHmY8zHiY8TDjYcbDjIcZDzMeZjzMeJjxMONhxsOMh4k87LnGCznwQg68kAMv5MALOfBCDryQAy/kQECCEJggBCgIgQpCwIIQuCAEMAiBDEJAgxDYIAQ4CIEOQsCDEPggBEAIgRBCQIQQGCEESAiBEkLAhBA4IQRQCIEUQkCFEFghBFiIeVr4tPmZp4XPJYmXZE7S375BbP2S9UusxPolVmL9EiuxfomVWL/ESqxfYiXWL7ES65dYifVLrMT6JeuXrF+yfumusX7J+iXrl+4a65esX7J+6a6xfsn6JeuX7hrrl76hXxpGvxbHbrHcbsb7XcYXL7vVdN3LMDz/PkyvTBfCHI771WZ9OW7Gq2Eet8KM771v69COGxlDMnzk1sNHzuNHUsMz19b+MSE1NVL7aLn+O6EftvoH","file_map":{"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    /// Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"62":{"source":"use dep::std;\n// Create a 3 x 3 Sujiko Verifier circuit \n\n/// Question will be in the form of  \n/// q[0]  q[1]\n/// q[2]  q[3]\n\n/// solution will be in the form of \n/// s[0]  s[1]  s[2]\n/// s[3]  s[4]  s[5]\n/// s[6]  s[7]  s[8]\n\n\nfn main(question: pub [Field; 4], solution:[Field; 9]) {\n   \n    // Your solution starts here ..\n    std::println(\"Question: \");\n    std::println(question);\n    std::println(\"Solution: \");\n    std::println(solution);\n\n}\n\n// Helper function\nfn is_equal(a:Field, b:Field) -> pub bool {\n    let z = a == b;\n    let m = false;\n    z| m \n}\n","path":"/Users/karlyu/noir-puzzles/circuits/Sujiko/circuits/src/main.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained"]}